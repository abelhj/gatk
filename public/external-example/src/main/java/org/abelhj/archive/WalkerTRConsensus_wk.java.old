package org.abelhj;
//package org.broadinstitute.gatk.utils.examples;

import org.broadinstitute.gatk.utils.commandline.Argument;
import org.broadinstitute.gatk.utils.commandline.Output;
import org.broadinstitute.gatk.utils.contexts.AlignmentContext;
import org.broadinstitute.gatk.utils.contexts.ReferenceContext;
import org.broadinstitute.gatk.utils.refdata.RefMetaDataTracker;
import org.broadinstitute.gatk.engine.walkers.ReadWalker;
import org.broadinstitute.gatk.engine.walkers.Reference;
import org.broadinstitute.gatk.engine.walkers.Window;
import org.broadinstitute.gatk.engine.walkers.TreeReducible;
import org.broadinstitute.gatk.utils.genotyper.DiploidGenotype;
import org.broadinstitute.gatk.utils.MathUtils;
import org.broadinstitute.gatk.utils.QualityUtils;
import org.broadinstitute.gatk.utils.help.DocumentedGATKFeature;
import org.broadinstitute.gatk.utils.help.HelpConstants;
import org.broadinstitute.gatk.utils.sam.GATKSAMRecord;
import org.broadinstitute.gatk.utils.sam.ReadUtils;
import org.abelhj.utils.TypedTuple;
import htsjdk.samtools.SAMUtils;
import org.broadinstitute.gatk.utils.GenomeLoc;
import org.broadinstitute.gatk.utils.GenomeLocParser;
import org.abelhj.utils.ReadFamily;
import org.abelhj.utils.ReadFamilyLead;

import htsjdk.samtools.SAMFileHeader;
import htsjdk.samtools.SAMFileWriter;
import htsjdk.samtools.SAMReadGroupRecord;
import htsjdk.samtools.SAMRecord;
import htsjdk.samtools.SAMFileWriterFactory;

import java.io.PrintStream;
import java.util.Arrays;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.List;
import java.io.BufferedWriter;
import java.io.PrintWriter;
import java.io.FileWriter;
import java.io.File;
import java.io.BufferedReader;


@Reference(window=@Window(start=-1, stop=1))
public class WalkerTRConsensus_wk extends ReadWalker<Integer,Integer>  {

    @Output
    PrintStream out;
    /**
     * Reads with mapping quality values lower than this threshold will be skipped. This is set to -1 by default to disable the evaluation and ignore this threshold.
     */

    @Argument(fullName = "consensusBam", shortName = "cbam", doc="consensus BAM ouput", required=true)
    String consensusBam=null;
    @Argument(fullName = "minMappingQuality", shortName = "mmq", doc = "Minimum mapping quality of reads to count towards depth", required = false, minValue = 0, maxValue = Integer.MAX_VALUE)
    int minMappingQuality = -1;
    @Argument(fullName = "debug", shortName = "debug", doc= "1 to print read groups and consensus to bcfile", required=false)
    boolean debug=false;
    @Argument(fullName = "bcfile", shortName = "bc", doc= "barcode list", required=false)
    String bcfile=null;
    @Argument(fullName = "maxNM", shortName = "maxNM", doc="filter reads with edit distance greater than maxNM", required=false)
    int maxNM=99;

    PrintStream bcout=null;
    SAMFileWriter samwriter=null;
    SAMFileWriterFactory sf=null;

    //Map<String, Map<Integer, Map<String, ReadFamilyLead> > bcmaster=null;
    Map<String, Map<Integer, Map<String, ReadFamily > > > bcreads;
    Map <String, Map<Integer, List< Amplicon> >  > ampliconMap;

    /*    Map<String, Map<String, Map<String, ReadFamilyLead> > > bcmaster=null;
    Map<String, Map<String, Map<Integer, LinkedList<GATKSAMRecord> > > > bcreads;
    Map <String, Map<Integer, List< Amplicon> >  > ampliconMap;*/



    String oldchr=null;
    String curchr=null;
    int oldpos=-1;
    int curpos=-1;
    String oldAmplicon=null;
    String curAmplicon=null;
    
    public void initialize() {

	ampliconMap=new LinkedHashMap <String, Map<Integer, List< Amplicon> >  >();
	try {
	    BufferedReader br = new BufferedReader(new FileReader(ampliconBed));
	    String line;
	    while ((line = br.readLine()) != null) {
		String[] spl=line.split("\t");
		String chr=spl[0];
		int start=Integer.parseInt(spl[1]);
		Amplicon amp=new Amplicon(chr, start, Integer.parseInt(spl[2]), spl[3]);
		if(!ampliconMap.containsKey(chr)) {
		    ampliconMap.put(chr, new LinkedHashMap<Integer, List<Amplicon> >());
		}
		if(!ampliconMap.get(chr).containsKey(start)) {
		    ampliconMap.get(chr).put(start, new List<Amplicon> ());
		}
		ampliconMap.get(chr).get(start).add(amp);
		}
	}
	catch (Exception e) {
	    e.printStackTrace();
	}
	if(debug) {
	    if(bcfile==null) {
		bcfile=consensusBam+".debug.txt";
	    }
	    try {
		bcout=new PrintStream(new File(bcfile));
	    } catch(Exception e) {
		System.err.println("Could not create debug output file.\n");
	    }
	}
	//bcmaster=new LinkedHashMap<String, Map<String, Map<String, ReadFamilyLead> > >();
	bcreads=new LinkedHashMap<String, Map<Integer, Map<String, ReadFamily > > >();
	//bcreads=new LinkedHashMap<String, Map<String, Map<String, List<GATKSAMRecord> > > >();
	sf=new SAMFileWriterFactory();
	samwriter=sf.makeBAMWriter(this.getToolkit().getSAMFileHeader(), true, new File(consensusBam), 5);
    }

    public Integer map(ReferenceContext ref, GATKSAMRecord read, RefMetaDataTracker tracker) {
	
	if(ref!=null) {
	    if (ref.getBase() == 'N' || ref.getBase() == 'n') return null; // we don't deal with the N ref base case
	    //curpos=ref.getLocus();
	    curchr=read.getReferenceName();
	    curpos=read.getAlignmentStart();
	    if(curpos>oldpos ||  !(curchr.equals(oldchr))) {         //find last possible current amplicon
		String last="";
		Map amap=ampliconMap.get(curchr);
		for(Integer ii : amap.keySet()) {
		    if(abs(ii-curpos)<500) {
			for(Amplicon amp : amap.get(ii)) {
			    if(curpos>amp.getStart() && curpos<amp.getEnd()) {
				curAmplicon=amp.getName();
			    }
			}
		    }
		}
	    }
			
	    //if we've gone past an amplicon, condense whatever we can
	    if(oldAmplicon!=null && !curAmplicon.equals(oldAmplicon)) {
		//System.out.println("-----------------------------"+curchr+":"+curpos+"\t"+oldchr+":"+oldpos);
		for(String bc : bcreads.keySet()) {

		    ReadFamilyAmp=new ReadFamilyAmp(onebcmap, bc, ampliconMap);
		     }
		     if(seenBothEnds) {
		     	collapse=true;
		     } else if (threeprime>oldAmplicon.getEnd()+500) {
		     	collapse=true;
		     }
		    if(collapse) {
			ReadFamily rf=new ReadFamilyAmp(onebcmap);
			rf.getConsensus(bcout, samwriter);
		    }
		}
		oldpos=curpos;
		oldchr=curchr;
		oldAmplicon=curAmplicon;
	    }
	    String bc=read.getStringAttribute("X0");
	    if(!bcreads.containsKey(bc)) {
		bcreads.put(bc, new LinkedHashMap<String, List<GATKSAMRecord> >());
	    }
	    if(!bcreads.get(bc).containsKey(read.getName())) {
		bcreads.get(bc).put(read.getName(), new ArrayList<GATKSAMRecord>());
	    }
	    bcreads.get(bc).get(read.getName()).add(read);
	}
	return 1;
    }
   
    public Integer reduceInit() {
        return 0;
    }

    public Integer reduce(Integer value, Integer sum) {
        return 0;
    }

    public void onTraversalDone(Integer result) {
	for(String bc : bcreads.keySet()) {
	    for (Integer ii : bcreads.get(bc).keySet()) {
		ReadFamily rf=new ReadFamily(bcreads.get(bc).get(ii));
		//System.out.println(rf);
		rf.getConsensus(bcout, bcmaster, samwriter);
	    }
	}
	samwriter.close();
    }

    public Amplicon getNearestAmplicon(Map <String, List<GATKSAMRecord> > onebcmap, <String, Map<Integer, List< Amplicon> >  >ampliconMap) {




    }
}
